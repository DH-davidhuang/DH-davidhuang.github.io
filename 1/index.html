<!DOCTYPE html>
<html>
<head>
    <title>Project 1: Image Alignment and Colorization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }

        h1, h2 {
            color: #333;
        }

        a {
            color: #0066cc;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        section {
            margin-bottom: 40px;
        }

        p {
            text-align: justify;
            line-height: 1.6;
        }

        code {
            display: block;
            background-color: #f4f4f4;
            padding: 10px;
            border-left: 4px solid #ccc;
            margin-bottom: 20px;
        }

        .results img {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
        }

        figure img {
            max-width: 100;
            height: auto;
            display: block;
            margin: 0 auto;
        }
    
    </style>
</head>
<body>
    <h1>Project 1: Image Alignment and Colorization</h1>

    <section>
        <h2>Overview</h2>
        <p>
            This project implements methods to algorithmically colorize photos from Sergei Mikhailovich Prokudin-Gorskii (1863-1944) three channel collection.
        </p>
    </section>

    <section>
        <h2>Methods</h2>
        <p>
            The colorization process involves two steps: Image Alignment and Color Restoration. In the image alignment phase, we attempt to align the three channels as closely as possible by treating this as an optimization problem. The optimization is done using two key techniques: 
            <strong>Sum of Squared Differences (SSD)</strong> and <strong>Normalized Cross-Correlation (NCC)</strong>.
        </p>
        <p>
            SSD works by minimizing the error magnitude between two images, acting as a residual operator. NCC, on the other hand, works similarly to a dot product, aiming to find vectors that have the smallest angles between them. 
        </p>

        <h3>Optimization Functions: <code>argmax</code> and <code>min</code></h3>
        <p>
            In the alignment task, we optimize for the best displacement that aligns the color channels by either minimizing the SSD using <code>min</code> or maximizing the NCC using <code>argmax</code>. These functions help find the displacement that yields the best alignment score. For small images, we can perform an exhaustive search, but for larger images, we employ a pyramid search to recursively downscale the image and optimize over smaller regions.
        </p>
        <code>
            def ncc_align(image1, image2, window_size):<br>
                best_displacement = (0, 0)<br>
                best_ncc = -float('inf')<br>
                for x_displacement in range(-window_size, window_size+1):<br>
                    for y_displacement in range(-window_size, window_size+1):<br>
                        displacement = (x_displacement, y_displacement)<br>
                        image1_shifted = np.roll(image1, displacement, axis=(0,1))<br>
                        ncc = ssim(image1_shifted, image2, data_range=1.0)<br>
                        if ncc > best_ncc:<br>
                            best_ncc = ncc<br>
                            best_displacement = displacement<br>
                return best_displacement
        </code>
    </section>

    <section>
        <h2>Details and Techniques</h2>
        <p>
            In my implementation, I used the blue channel as the base image and aligned the red and green channels to it. I experimented with both SSD and NCC, and found that NCC provided better alignment results. For smaller images, I used a brute-force search over a displacement window, while for larger images, I implemented a pyramid search to reduce computation time.
        </p>

        <h3>Automatic Cropping</h3>
        <p>
            To clean up the images, I implemented an automatic cropping method that removes unnecessary white or black borders by detecting the edge between the border and the image content. The cropping is based on intensity thresholding and calculating the bounding box of the actual image content.
        </p>

        <h3>Automatic Contrast Adjustment</h3>
        <p>
            Additionally, I implemented an automatic contrast adjustment method to improve the visual quality of the image. This rescales the image intensity such that the darkest pixel is zero and the brightest pixel is one. This simple adjustment helps make the images more visually striking without any manual intervention.
        </p>
    </section>
    <section class="results">
        <h2>Results: Single-Scale Images</h2>
        <p>
            Below are the results from single-scale images, showing the baselines filtered by those that contain green and red displacement vectors in their filenames.
        </p>
        <div class="result-grid">
            <!-- monastery results -->
            <div class="result-set">
                <h3>Monastery</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/single-scale-small-images/_green_displacement_(-3, 2)_red_displacement_(3, 2)monastery.jpg" alt="Baseline Image - Green: -3,2 Red: 3,2">
                        <figcaption>Green Displacement: (-3, 2), Red Displacement: (3, 2)</figcaption>
                    </figure>
                </div>
            </div>
    
            <!-- cathedral results -->
            <div class="result-set">
                <h3>Cathedral</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/single-scale-small-images/_green_displacement_(5, 2)_red_displacement_(12, 3)cathedral.jpg" alt="Baseline Image - Green: 5,2 Red: 12,3">
                        <figcaption>Green Displacement: (5, 2), Red Displacement: (12, 3)</figcaption>
                    </figure>
                </div>
            </div>
    
            <!-- tobolsk results -->
            <div class="result-set">
                <h3>Tobolsk</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/single-scale-small-images/_green_displacement_(3, 2)_red_displacement_(6, 3)tobolsk.jpg" alt="Baseline Image - Green: 3,2 Red: 6,3">
                        <figcaption>Green Displacement: (3, 2), Red Displacement: (6, 3)</figcaption>
                    </figure>
                </div>
            </div>
        </div>DH-davidhuang.github.io/1/media/single-scale-small-images
    </section>

    <section class="results">
        <h2>Results: Pyramid Displacement Images</h2>
        <p>
            Below are the results from the pyramid displacement images, filtered by those that contain green and red displacement vectors in their filenames.
        </p>
        <div class="result-grid">
            <!-- church results -->
            <div class="result-set">
                <h3>Church</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/sobel_without_cropping/church_green_displacement_(25, 4)_red_displacement_(58, -4).jpg" alt="Church Green Displacement: 25,4 Red Displacement: 58,-4">
                        <figcaption>Green Displacement: (25, 4), Red Displacement: (58, -4)</figcaption>
                    </figure>
                </div>
            </div>
    
            <!-- melons results -->
            <div class="result-set">
                <h3>Melons</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/sobel_without_cropping/melons_green_displacement_(87, 7)_red_displacement_(177, 12).jpg" alt="Melons Green Displacement: 87,7 Red Displacement: 177,12">
                        <figcaption>Green Displacement: (87, 7), Red Displacement: (177, 12)</figcaption>
                    </figure>
                </div>
            </div>
    
            <!-- onion_church results -->
            <div class="result-set">
                <h3>Onion Church</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/sobel_without_cropping/onion_church_green_displacement_(52, 24)_red_displacement_(107, 35).jpg" alt="Onion Church Green Displacement: 52,24 Red Displacement: 107,35">
                        <figcaption>Green Displacement: (52, 24), Red Displacement: (107, 35)</figcaption>
                    </figure>
                </div>
            </div>
    
            <!-- train results -->
            <div class="result-set">
                <h3>Train</h3>
                <div class="result-row">
                    <figure>
                        <img src="media/sobel_without_cropping/train_green_displacement_(41, 1)_red_displacement_(85, 29).jpg" alt="Train Green Displacement: 41,1 Red Displacement: 85,29">
                        <figcaption>Green Displacement: (41, 1), Red Displacement: (85, 29)</figcaption>
                    </figure>
                </div>
            </div>
        </div>
    </section>
    
    <style>
        .result-grid {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
    
        .result-set {
            margin-bottom: 20px;
        }
    
        .result-row {
            display: flex;
            gap: 20px;
            justify-content: flex-start;
        }
    
        figure {
            margin: 0;
            text-align: center;
        }
    
        figure img {
            max-width: 100;
            height: auto;
            display: block;
            margin: 0 auto;
        }
    
        figure figcaption {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
    

    <section>
        <h2>Conclusion</h2>
        <p>
            The project successfully automates the process of aligning and colorizing the digitized images from Prokudin-Gorskii's collection. The results demonstrate that NCC generally produces better alignment compared to SSD, and the pyramid search significantly reduces computation time for larger images.
        </p>
    </section>

    <a href="../index.html">Back to Main Portfolio</a>
</body>
</html>
